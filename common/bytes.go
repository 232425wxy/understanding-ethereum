package common

import (
	"encoding/hex"
	"errors"
	"github.com/232425wxy/understanding-ethereum/common/hexutil"
)

/*â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“*/

// API

// FromHex â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/11/19|
//
// FromHex æ–¹æ³•æ¥å—ä¸€ä¸ª16è¿›åˆ¶ç¼–ç çš„å­—ç¬¦ä¸²ä½œä¸ºå…¥å‚ï¼Œè¯¥å­—ç¬¦ä¸²å¯èƒ½å«æœ‰"0x"æˆ–"0X"å‰ç¼€ï¼Œå¦‚æœæœ‰çš„è¯ï¼Œ
// åˆ™å°†å…¶å»é™¤æ‰ï¼Œç„¶åå°†å‰©ä½™çš„éƒ¨åˆ†åˆ©ç”¨ hex.DecodeString æ–¹æ³•è§£ç æˆå­—ç¬¦ä¸²ï¼Œæœ€ç»ˆè¿”å›ç»“æœçš„å­—èŠ‚åˆ‡
// ç‰‡å½¢å¼ã€‚
func FromHex(s string) []byte {
	if has0xPrefix(s) {
		s = s[2:]
	}
	if len(s)%2 == 1 {
		s = "0" + s
	}
	return Hex2Bytes(s)
}

// CopyBytes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/11/19|
//
// CopyBytes æ¥å—ä¸€ä¸ªå­—èŠ‚åˆ‡ç‰‡ä½œä¸ºè¾“å…¥å‚æ•°ï¼Œç„¶åå¤åˆ¶è¿™ä¸ªå­—èŠ‚åˆ‡ç‰‡ï¼Œå¹¶å°†å¤åˆ¶å“è¿”å›å‡ºå»ã€‚
func CopyBytes(bz []byte) (cpy []byte) {
	if bz == nil {
		return nil
	}
	cpy = make([]byte, len(bz))
	copy(cpy, bz)
	return cpy
}

// Hex2Bytes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/11/19|
//
// Hex2Bytes æ–¹æ³•æ¥å—ä¸€ä¸ª16ç¦æ­¢ç¼–ç çš„å­—ç¬¦ä¸²ï¼Œè¯¥å­—ç¬¦ä¸²ä¸èƒ½å«æœ‰"0x"æˆ–"0X"å‰ç¼€ï¼Œç„¶åå°†ç»™å®šçš„å­—ç¬¦ä¸²
// åˆ©ç”¨ hex.DecodeString æ–¹æ³•è§£ç æˆå­—ç¬¦ä¸²ï¼Œæœ€ç»ˆè¿”å›ç»“æœçš„å­—èŠ‚åˆ‡ç‰‡å½¢å¼ã€‚
func Hex2Bytes(str string) []byte {
	h, _ := hex.DecodeString(str)
	return h
}

// Bytes2Hex â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/11/19|
//
// Bytes2Hex æ–¹æ³•æ¥å—ä¸€ä¸ªå­—èŠ‚åˆ‡ç‰‡ä½œä¸ºè¾“å…¥å‚æ•°ï¼Œç„¶åè°ƒç”¨ hex.EncodeToString æ–¹æ³•å°†è¯¥å­—èŠ‚åˆ‡ç‰‡ç¼–ç æˆ
// 16è¿›åˆ¶çš„å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚å°†"Hello"ç¼–ç æˆ"48656c6c6f"ã€‚
func Bytes2Hex(bz []byte) string {
	return hex.EncodeToString(bz)
}

// ParseHexOrString â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/11/19|
//
// ParseHexOrString æ–¹æ³•æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸ºè¾“å…¥å‚æ•°ï¼Œå¦‚æœè¾“å…¥çš„å­—ç¬¦ä¸²ä¸å«æœ‰"0x"æˆ–"0X"å‰ç¼€ï¼Œåˆ™è¿”å›è¾“å…¥
// çš„å­—ç¬¦ä¸²æœ¬èº«ï¼Œå¦åˆ™è°ƒç”¨ hex.DecodeString æ–¹æ³•å»è§£ç å‰ç¼€ä¹‹åçš„å­—ç¬¦ä¸²ã€‚
func ParseHexOrString(str string) ([]byte, error) {
	bz, err := hexutil.Decode(str)
	if errors.Is(err, hexutil.ErrMissingPrefix) {
		return []byte(str), nil
	}
	return bz, err
}

// RightPadBytes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/11/19|
//
// RightPadBytes æ–¹æ³•æ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå­—èŠ‚åˆ‡ç‰‡ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ªæ•´æ•°lï¼Œè¯¥æ–¹æ³•çš„ç›®çš„å°±æ˜¯å°†å­—èŠ‚
// åˆ‡ç‰‡çš„é•¿åº¦æ‰©å±•æˆlï¼Œå³è¾¹æ–°å¢çš„å­—èŠ‚å°†ç”¨0æ¥å¡«å……ã€‚
func RightPadBytes(slice []byte, l int) []byte {
	if l <= len(slice) {
		return slice
	}

	padded := make([]byte, l)
	copy(padded, slice)

	return padded
}

// LeftPadBytes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/11/19|
//
// LeftPadBytes æ–¹æ³•æ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå­—èŠ‚åˆ‡ç‰‡ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ªæ•´æ•°lï¼Œè¯¥æ–¹æ³•çš„ç›®çš„å°±æ˜¯å°†å­—èŠ‚
// åˆ‡ç‰‡çš„é•¿åº¦æ‰©å±•æˆlï¼Œå·¦è¾¹æ–°å¢çš„å­—èŠ‚å°†ç”¨0æ¥å¡«å……ã€‚
func LeftPadBytes(slice []byte, l int) []byte {
	if l <= len(slice) {
		return slice
	}

	padded := make([]byte, l)
	copy(padded[l-len(slice):], slice)

	return padded
}

// TrimLeftZeroes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/11/19|
//
// TrimLeftZeroes æ¥å—ä¸€ä¸ªå­—èŠ‚åˆ‡ç‰‡ä½œä¸ºè¾“å…¥å‚æ•°ï¼Œè¯¥æ–¹æ³•çš„ç›®çš„å°±æ˜¯å°†ç»™å®šçš„å­—èŠ‚åˆ‡ç‰‡å·¦è¾¹çš„æ‰€æœ‰0ç»™å»æ‰ï¼Œç„¶åè¿”å›
// å³è¾¹å‰©ä¸‹çš„å­—èŠ‚åˆ‡ç‰‡ã€‚
func TrimLeftZeroes(s []byte) []byte {
	idx := 0
	for ; idx < len(s); idx++ {
		if s[idx] != 0 {
			break
		}
	}
	return s[idx:]
}

// TrimRightZeroes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/11/19|
//
// TrimRightZeroes æ¥å—ä¸€ä¸ªå­—èŠ‚åˆ‡ç‰‡ä½œä¸ºè¾“å…¥å‚æ•°ï¼Œè¯¥æ–¹æ³•çš„ç›®çš„å°±æ˜¯å°†ç»™å®šçš„å­—èŠ‚åˆ‡ç‰‡å³è¾¹çš„æ‰€æœ‰0ç»™å»æ‰ï¼Œç„¶åè¿”å›
// å·¦è¾¹å‰©ä¸‹çš„å­—èŠ‚åˆ‡ç‰‡ã€‚
func TrimRightZeroes(s []byte) []byte {
	idx := len(s)
	for ; idx > 0; idx-- {
		if s[idx-1] != 0 {
			break
		}
	}
	return s[:idx]
}

/*â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“*/

// ä¸å¯å¯¼å‡ºçš„å‡½æ•°

// has0xPrefix â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/11/19|
//
// has0xPrefix æ–¹æ³•æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸ºå…¥å‚ï¼Œå¹¶åˆ¤æ–­è¯¥å­—ç¬¦ä¸²æ˜¯å¦å«æœ‰"0x"æˆ–"0X"å‰ç¼€ã€‚
func has0xPrefix(str string) bool {
	return len(str) >= 2 && str[0] == '0' && (str[1] == 'x' || str[1] == 'X')
}

// isHexCharacter â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/11/19|
//
// isHexCharacter æ–¹æ³•æ¥å—ä¸€ä¸ªå­—èŠ‚ä½œä¸ºè¾“å…¥å‚æ•°ï¼Œç„¶ååˆ¤æ–­è¯¥å­—èŠ‚æ˜¯ä¸æ˜¯åˆæ³•çš„16è¿›åˆ¶å­—èŠ‚ï¼Œ16è¿›åˆ¶å­—èŠ‚çš„å–å€¼èŒƒå›´å¦‚ä¸‹æ‰€ç¤ºï¼š
//
//	'0' ~ '9' | 'a' ~ 'f' | 'A' ~ 'F'
func isHexCharacter(c byte) bool {
	return ('0' <= c && c <= '9') || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F')
}

// isHex â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/11/19|
//
// isHex æ–¹æ³•æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸ºè¾“å…¥å‚æ•°ï¼Œè¯¥æ–¹æ³•çš„åŠŸèƒ½æ˜¯åˆ¤æ–­å­—ç¬¦ä¸²é‡Œçš„æ¯ä¸ªå­—èŠ‚æ˜¯å¦éƒ½åœ¨16è¿›åˆ¶å­—èŠ‚çš„å–å€¼èŒƒå›´ä¹‹å†…ï¼ŒåŒæ—¶è¿˜
// éœ€è¦åˆ¤æ–­ç»™å®šçš„å­—ç¬¦ä¸²çš„é•¿åº¦æ˜¯å¦ä¸ºå¶æ•°ï¼Œå› ä¸º16è¿›åˆ¶ç¼–ç çš„å†…å®¹ï¼Œä¸¤ä¸ªå­—èŠ‚ä»£è¡¨ä¸€ä¸ªå­—èŠ‚ã€‚ä¾‹å¦‚å­—èŠ‚'00010010'(18)çš„16è¿›åˆ¶
// ç¼–ç ç»“æœä¸ºï¼š'00000001 00000010'(1 2)ã€‚
func isHex(str string) bool {
	if len(str)%2 != 0 {
		return false
	}
	for _, c := range []byte(str) {
		if !isHexCharacter(c) {
			return false
		}
	}
	return true
}

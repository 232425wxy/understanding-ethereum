package hexutil

import "encoding/hex"

/*â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“*/

// Bytes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/10/26|
//
// æˆ‘ä»¬è‡ªå·±å®šä¹‰äº†ä¸€ä¸ªåˆ‡ç‰‡ç±»å‹Bytesï¼Œå®ƒçš„åº•å±‚å®ç°å°±æ˜¯[]byteï¼Œå®šä¹‰è¯¥ç±»å‹çš„ç›®çš„æ˜¯æ–¹ä¾¿å¯¹å­—èŠ‚åˆ‡ç‰‡è¿›è¡Œç¼–è§£ç ã€‚
type Bytes []byte

// MarshalText â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/10/26|
//
// è¯¥æ–¹æ³•å®ç°äº† encoding.TextMarshaler æ¥å£ï¼Œè¯¥æ–¹æ³•çš„ä½œç”¨å°±æ˜¯å°†å­—èŠ‚åˆ‡ç‰‡è½¬æ¢ä¸º16è¿›åˆ¶æ•°æ®ï¼Œ
// æˆ‘ä»¬çŸ¥é“ä¸€ä¸ªå­—èŠ‚å¯ä»¥ä»£è¡¨ä¸¤ä¸ª16è¿›åˆ¶æ•°ï¼Œæ‰€ä»¥è½¬æ¢ä¸º16è¿›åˆ¶æ•°æ®åï¼Œé•¿åº¦ä¼šæ‰©å¤§ä¸€å€ï¼Œåªæ˜¯åœ¨æ­¤
// åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬è¿˜è¦åœ¨è½¬æ¢åçš„æ•°æ®å‰åŠ ä¸Š`0x`å‰ç¼€ï¼Œæ‰€ä»¥é•¿åº¦è¿˜è¦å†åŠ 2ã€‚
func (b Bytes) MarshalText() ([]byte, error) {
	result := make([]byte, len(b)*2+2)
	copy(result, `0x`)
	hex.Encode(result[2:], b) // hexåŒ…æœ‰å®ƒè‡ªå·±çš„ç¼–ç è§„åˆ™
	return result, nil
}

// UnmarshalText â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/10/26|
//
// UnmarshalTextæ–¹æ³•å®ç°äº†encoding.TextUnmarshaleræ¥å£ï¼Œè¯¥æ–¹æ³•å°†MarshalTextçš„ç¼–ç ç»“æœè§£ç æˆåŸå§‹æ•°æ®ã€‚

/*â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“*/

// bytesHave0xPrefix â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/10/26|
//
// åˆ¤æ–­ç»™å®šçš„å­—èŠ‚åˆ‡ç‰‡æ˜¯å¦å«æœ‰"0x"æˆ–"0X"å‰ç¼€ï¼Œè¯¥æ–¹æ³•ç›¸å½“äº has0xPrefix(string(input)) æ–¹æ³•çš„æ•ˆæœã€‚
func bytesHave0xPrefix(input []byte) bool {
	return len(input) >= 2 && input[0] == '0' && (input[1] == 'x' || input[1] == 'X')
}

// checkText â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/10/26|
//
// å¯¹ç»™å®šçš„å­—èŠ‚åˆ‡ç‰‡è¿›è¡Œæ£€æŸ¥ï¼Œæ£€æŸ¥åˆ†ä¸¤ç§æƒ…å†µè¿›è¡Œï¼š
//	1. å¦‚æœç¬¬äºŒä¸ªè¾“å…¥å‚æ•°çš„å€¼æ˜¯trueï¼Œåˆ™å½“ç»™å®šçš„å­—èŠ‚åˆ‡ç‰‡ç¬¦åˆä»¥ä¸‹æƒ…å†µä¹‹ä¸€ï¼ŒcheckText æ–¹æ³•å°±ä¼šæŠ¥é”™ï¼š
//		- ç»™å®šçš„å­—èŠ‚åˆ‡ç‰‡ä¸å«æœ‰"0x"æˆ–è€…"0X"å‰ç¼€ï¼Œä¾‹å¦‚ï¼š['a', 'b', 'c', 'd']
//		- ç»™å®šçš„å­—èŠ‚åˆ‡ç‰‡é•¿åº¦æ˜¯å¥‡æ•°ï¼Œä¾‹å¦‚ï¼š['a', 'b', 'c']
//	2. å¦‚æœç¬¬äºŒä¸ªè¾“å…¥å‚æ•°çš„å€¼æ˜¯falseï¼Œåˆ™å½“ç»™å®šçš„å­—èŠ‚åˆ‡ç‰‡ç¬¦åˆä»¥ä¸‹æƒ…å†µï¼ŒcheckText æ–¹æ³•å°±ä¼šæŠ¥é”™ï¼š
//		- ç»™å®šçš„å­—èŠ‚åˆ‡ç‰‡é•¿åº¦æ˜¯å¥‡æ•°ï¼Œä¾‹å¦‚ï¼š['a', 'b', 'c']
// å¦‚æœç»™å®šçš„åˆ‡ç‰‡åˆæ³•ï¼Œå¹¶ä¸”å‡å¦‚ç»™å®šçš„åˆ‡ç‰‡å«æœ‰"0x"æˆ–è€…"0X"å‰ç¼€ï¼Œåˆ™å°†å…¶å‰ç¼€å»æ‰å¹¶è¿”å›ï¼Œå¦åˆ™ä¸åšä»»ä½•æ”¹å˜ç›´æ¥è¿”å›è¯¥åˆ‡ç‰‡ã€‚
func checkText(input []byte, wantPrefix bool) ([]byte, error) {
	if len(input) == 0 {
		return nil, nil
	}
	if bytesHave0xPrefix(input) {
		input = input[2:]
	} else if wantPrefix { // æ²¡æœ‰å‰ç¼€ï¼Œä½†æ˜¯åˆæƒ³æœ‰å‰ç¼€
		return nil, ErrMissingPrefix
	}
	if len(input)%2 != 0 {
		return nil, ErrOddLength
	}
	return input, nil

}
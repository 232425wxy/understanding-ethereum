package hexutil

import "fmt"

/*â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“*/

// uintBits â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/10/26|
//
// uintBitså®šä¹‰äº†ä¸€ä¸ªuintç±»å‹å ç”¨äº†å¤šå°‘ä¸ªæ¯”ç‰¹ä½ï¼Œä¸€èˆ¬æ¥è®²uintç±»å‹çš„æ•°æ®è¦ä¹ˆå æ®32ä½ï¼Œè¦ä¹ˆå æ®64ä½ï¼Œ
// æ‰€ä»¥ï¼Œæˆ‘ä»¬å…ˆè·å–uintç±»å‹çš„æœ€å¤§å€¼ï¼š^uint(0)ï¼Œç„¶åå°†å…¶å³ç§»63ä¸ªæ¯”ç‰¹ä½ï¼Œå¦‚æœæœ¬ç³»ç»Ÿæ”¯æŒçš„æ˜¯64ä½æ“ä½œç³»
// ç»Ÿï¼Œé‚£ä¹ˆ^uint(0)å³ç§»63ä½åº”å½“ç­‰äº1ï¼Œå¦åˆ™ç­‰äº0ã€‚
// ä¸‹é¢çš„ä»£ç ä¸[const uintBits = 32 << (^uint(0) >> 63)]ç­‰æ•ˆã€‚
const uintBits = 32 << (uint64(^uint(0)) >> 63)

/*â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“*/

// decError â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/10/26|
//
// åœ¨è§£ç 16è¿›åˆ¶å­—ç¬¦ä¸²æ•°æ®æ—¶å¯èƒ½é‡åˆ°å„ç§å„æ ·çš„é”™è¯¯ï¼ŒdecErrorè´Ÿè´£å¯¹è¿™äº›é”™è¯¯è¿›è¡Œç»Ÿä¸€ç®¡ç†ã€‚
type decError struct {
	msg string
}

func (err decError) Error() string {
	return err.msg
}

// Errors â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/10/26|
//
// å®šä¹‰äº†9ä¸ªé¡¹ç›®å…¨å±€èŒƒå›´å†…çš„decErrorå®ä¾‹ï¼Œç”¨æ¥åæ˜ åœ¨è§£ç 16è¿›åˆ¶å­—ç¬¦ä¸²æ—¶å¯èƒ½é‡åˆ°çš„é”™è¯¯ã€‚
var (
	// ErrEmptyString å¦‚æœç»™å®šçš„16è¿›åˆ¶æ•°æ˜¯ç©ºçš„ï¼Œå°±æ˜¯è¿å‰ç¼€éƒ½ä¸å«æœ‰ï¼Œåˆ™æŠ¥å‘Šè¯¥é”™è¯¯ã€‚
	ErrEmptyString = &decError{msg: "empty hex string"}
	// ErrSyntax 16è¿›åˆ¶æ•°çš„å–å€¼èŒƒå›´æ˜¯[0, F]ï¼Œä¸€ä¸€ä¾‹ä¸¾çš„è¯å°±æ˜¯ï¼š{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f}ï¼Œ
	// ä¸åœ¨è¿™ä¸ªèŒƒå›´å†…çš„éƒ½ä¼šæŠ¥è¿™ä¸ªé”™è¯¯ã€‚
	ErrSyntax        = &decError{msg: "invalid hex string"}
	ErrMissingPrefix = &decError{msg: "hex string without 0x prefix"}
	// ErrOddLength 16è¿›åˆ¶æ•°ç”±å››ä¸ªæ¯”ç‰¹è¡¨ç¤ºï¼Œè¡¨ç¤ºèŒƒå›´æ˜¯[0000, 1111]ï¼Œè€Œä¸€ä¸ªå­—èŠ‚ç”±8ä¸ªæ¯”ç‰¹ç»„æˆï¼Œå› æ­¤ä¸€ä¸ªå­—èŠ‚å¯ä»¥ä»£è¡¨ä¸¤ä¸ª16è¿›åˆ¶
	// æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´å¿…é¡»ä¸¤ä¸ª16è¿›åˆ¶æ•°æ‰èƒ½ç»„æˆä¸€ä¸ªå­—èŠ‚ï¼Œæ‰€ä»¥ä¸€ä¸ªæ•°æ®è¢«ç¼–ç æˆ16è¿›åˆ¶æ•°ï¼Œé‚£ä¹ˆç»“æœçš„é•¿åº¦å¿…ç„¶æ˜¯å¶æ•°ã€‚
	ErrOddLength = &decError{msg: "hex string of odd length"}
	// ErrEmptyNumber å¦‚æœç»™å®šçš„16è¿›åˆ¶æ•°ç­‰äº0ï¼Œæ¢å¥è¯è¯´å°±æ˜¯åªæœ‰"0x"å‰ç¼€ï¼Œåˆ™æŠ¥å‘Šè¯¥é”™è¯¯ï¼Œå®ƒä¸ErrEmptyStringæœ‰ä¸€ç‚¹ç‚¹ä¸ä¸€æ ·ã€‚
	ErrEmptyNumber = &decError{msg: "hex string \"0x\""}
	// ErrLeadingZero å¦‚æœç»™å®šçš„16è¿›åˆ¶æ•°ä¸ç­‰äº0ï¼Œä½†æ˜¯ç´§è·Ÿåœ¨å‰ç¼€"0x"åé¢çš„æ•°æ˜¯"0"ï¼Œåˆ™æŠ¥å‘Šæ­¤é”™è¯¯ã€‚
	ErrLeadingZero = &decError{msg: "hex number with leading zero digits"}
	// ErrUint64Range ä¸€ä¸ª64ä½çš„æ— ç¬¦å·æ•´å‹ç”±8ä¸ªå­—èŠ‚ç»„æˆ
	ErrUint64Range = &decError{msg: "hex number > 64 bits"}
	ErrUintRange   = &decError{msg: fmt.Sprintf("hex number > %d bits", uintBits)}
	ErrBig256Range = &decError{msg: "hex number > 256 bits"}
)

// has0xPrefix â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/10/26|
//
// åˆ¤æ–­ç»™å®šçš„å­—ç¬¦ä¸²æ˜¯å¦å«æœ‰å‰ç¼€"0x"æˆ–è€…"0X"ã€‚
func has0xPrefix(str string) bool {
	return len(str) >= 2 && str[0] == '0' && (str[1] == 'x' || str[1] == 'X')
}

// checkNumber â™ |ä½œè€…ï¼šå´ç¿”å®‡| ğŸ |æ—¥æœŸï¼š2022/10/26|
//
// åˆ¤æ–­ç»™å®šçš„16è¿›åˆ¶æ•°ï¼ˆå­—ç¬¦ä¸²å½¢å¼ï¼‰æ ¼å¼æ˜¯å¦åˆæ³•ï¼Œä»¥ä¸‹å‡ ç§æƒ…å†µçš†ä¸ºä¸åˆæ³•ï¼š
//  1. ç»™å®šçš„å­—ç¬¦ä¸²ä¸ºç©ºï¼š""
//  2. ç»™å®šçš„å­—ç¬¦ä¸²æ²¡æœ‰å‰ç¼€ï¼š"1234"
//  3. ç»™å®šçš„å­—ç¬¦ä¸²åªå«æœ‰å‰ç¼€ï¼š"0x" æˆ– "0X"
//  4. ç»™å®šçš„éé›¶16è¿›åˆ¶æ•°çš„å­—ç¬¦ä¸²å¼€å¤´ç­‰äº0ï¼š"0x01"
//
// å¦‚æœç»™å®šçš„16è¿›åˆ¶æ•°æ˜¯åˆæ³•çš„ï¼Œåˆ™å»æ‰è¯¥æ•°çš„"0x"å‰ç¼€ï¼Œå¹¶è¿”å›å‰©ä¸‹çš„éƒ¨åˆ†ï¼Œä¾‹å¦‚"0x1234"å¾—åˆ°"1234"
func checkNumber(number string) (raw string, err error) {
	if len(number) == 0 {
		return "", ErrEmptyString
	}
	if !has0xPrefix(number) {
		return "", ErrMissingPrefix
	}
	withoutPrefix := number[:2]
	if len(withoutPrefix) == 0 {
		return "", ErrEmptyNumber
	}
	if len(withoutPrefix) > 1 && withoutPrefix[0] == '0' {
		return "", ErrLeadingZero
	}
	return withoutPrefix, nil
}

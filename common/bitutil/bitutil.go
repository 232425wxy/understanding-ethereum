/*
Package bitutil
è¯¥æ–‡ä»¶å®šä¹‰äº†è‹¥å¹²å¯¹01æ¯”ç‰¹çš„æ“ä½œæ–¹æ³•ï¼š
	- å¼‚æˆ–è¿ç®—
	- ä¸Žè¿ç®—
	- æˆ–è¿ç®—
	- æ£€æŸ¥ç»™å®šå­—èŠ‚åˆ‡ç‰‡ä¸­æ˜¯å¦å­˜åœ¨å€¼ä¸ºéž0çš„å­—èŠ‚
*/
package bitutil

import (
	"runtime"
	"unsafe"
)

/*â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“*/

// wordSize â™ |ä½œè€…ï¼šå´ç¿”å®‡| ðŸ |æ—¥æœŸï¼š2022/10/27|
//
// wordSizeè¡¨ç¤ºå­˜å‚¨ä¸€ä¸ªæŒ‡é’ˆæ•°æ®éœ€è¦å¤šå°‘ä¸ªå­—èŠ‚ï¼Œåœ¨64ä½çš„Ubuntu 20.04æ“ä½œç³»ç»Ÿä¸­ï¼ŒwordSize çš„å€¼ç­‰äºŽ8.
const wordSize = int(unsafe.Sizeof(uintptr(0)))

// supportUnaligned â™ |ä½œè€…ï¼šå´ç¿”å®‡| ðŸ |æ—¥æœŸï¼š2022/10/27|
//
// supportUnalignedç”¨æ¥è¡¨ç¤ºå½“å‰çš„è®¡ç®—æœºæž¶æž„æ˜¯å¦æ”¯æŒå†…å­˜ä¸å¯¹é½ï¼Œåœ¨64ä½çš„Ubuntu 20.04æœºå™¨ä¸Šï¼ŒsupportAlignedçš„å€¼æ’ä¸ºtrueã€‚
const supportUnaligned = runtime.GOARCH == "386" || runtime.GOARCH == "amd64" || runtime.GOARCH == "ppc64" || runtime.GOARCH == "ppc64le" || runtime.GOARCH == "s390x"

/*â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“*/

// ðŸŒ¹å¼‚æˆ–è¿ç®—ðŸŒ¹

// XORBytes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ðŸ |æ—¥æœŸï¼š2022/10/27|
//
// XORBytes æ–¹æ³•æŽ¥å—ä¸‰ä¸ªå…¥å‚ï¼Œåˆ†åˆ«æ˜¯dstã€aã€bä¸‰ä¸ªå­—èŠ‚åˆ‡ç‰‡ï¼Œè¯¥æ–¹æ³•å®žçŽ°å¯¹ç»™å®šçš„aã€bä¸¤ä¸ªå­—èŠ‚åˆ‡ç‰‡è¿›è¡Œå¼‚æˆ–è¿ç®—ï¼Œå¹¶å°†ç»“æžœ
// å­˜å‚¨åˆ°dstä¸­ï¼Œå¦‚æžœè¿è¡Œè¯¥æ–¹æ³•çš„è®¡ç®—æœºæž¶æž„å±žäºŽ{386ã€amd64ã€ppc64ã€ppc64leã€s390x}è¿™å…¶ä¸­çš„æŸä¸€ä¸ªï¼Œåˆ™æ‰§è¡Œå¿«é€Ÿç®—æ³•
// fastXORBytes æ¥è¿›è¡Œå¼‚æˆ–è¿ç®—ï¼Œå¦åˆ™é‡‡ç”¨å¸¸è§„çš„ç®—æ³• safeXORBytesã€‚è¯¥æ–¹æ³•çš„è¿”å›žå€¼è¡¨ç¤ºå¯¹aæˆ–bä¸­å¤šå°‘ä¸ªå­—èŠ‚è¿›è¡Œäº†å¼‚æˆ–è¿ç®—ã€‚
//
//	ä¾‹å¦‚ï¼šè¾“å…¥a=[12 34 28] b=[3 67 98 55]ï¼Œç»è¿‡è¿ç®—ï¼Œdst=[15 97 126]
//	12 xor 3 -> 1100 ^ 0011 -> 1111 -> 15
//	34 xor 67 -> 0100010 ^ 1000011 -> 1100001 -> 97
//	28 xor 98 -> 0011100 ^ 1100010 -> 1111110 -> 126
func XORBytes(dst, a, b []byte) int {
	if supportUnaligned {
		return fastXORBytes(dst, a, b)
	}
	return safeXORBytes(dst, a, b)
}

// safeXORBytes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ðŸ |æ—¥æœŸï¼š2022/10/27|
//
// safeXORBytes æ–¹æ³•æŽ¥å—3ä¸ªå…¥å‚ï¼Œåˆ†åˆ«æ˜¯dstã€aã€bï¼Œè¯¥æ–¹æ³•å°±æ˜¯å¯¹ç»™å®šçš„aã€bä¸¤ä¸ªå­—èŠ‚åˆ‡ç‰‡ï¼Œè¿›è¡Œé€å­—èŠ‚çš„å¼‚æˆ–è¿ç®—ã€‚ä¸è¦æ±‚
// aã€bä¸¤ä¸ªå­—èŠ‚åˆ‡ç‰‡çš„é•¿åº¦å¿…é¡»ä¸€æ ·ï¼Œä½†æ˜¯è¦æ±‚dstå‚æ•°çš„é•¿åº¦è‡³å°‘ç­‰äºŽaã€bä¸­é•¿åº¦æœ€çŸ­çš„é‚£ä¸€ä¸ªï¼Œè¯¥æ–¹æ³•çš„è¿”å›žå€¼è¡¨ç¤ºå¯¹aæˆ–bä¸­å¤šå°‘
// ä¸ªå­—èŠ‚è¿›è¡Œäº†å¼‚æˆ–è¿ç®—ã€‚
//
//	ä¾‹å¦‚ï¼šè¾“å…¥a=[12 34 28] b=[3 67 98 55]ï¼Œç»è¿‡è¿ç®—ï¼Œdst=[15 97 126]
//	12 xor 3 -> 1100 ^ 0011 -> 1111 -> 15
//	34 xor 67 -> 0100010 ^ 1000011 -> 1100001 -> 97
//	28 xor 98 -> 0011100 ^ 1100010 -> 1111110 -> 126
func safeXORBytes(dst, a, b []byte) int {
	n := len(a)
	if len(b) < n {
		n = len(b)
	}
	for i := 0; i < n; i++ {
		dst[i] = a[i] ^ b[i]
	}
	return n
}

// fastXORBytes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ðŸ |æ—¥æœŸï¼š2022/10/27|
//
// fastXORBytes æ–¹æ³•æŽ¥å—3ä¸ªå…¥å‚ï¼Œåˆ†åˆ«æ˜¯dstã€aã€bï¼Œè¯¥æ–¹æ³•å°±æ˜¯å¯¹ç»™å®šçš„aã€bä¸¤ä¸ªå­—èŠ‚åˆ‡ç‰‡è¿›è¡Œå¼‚æˆ–è¿ç®—ï¼Œå¹¶å°†ç»“æžœå­˜åˆ°
// dstä¸­ï¼Œä½†æ˜¯è¯¥æ–¹æ³•æ¯” safeXORBytes æ–¹æ³•æ›´å¿«ï¼Œæ ¹æ®benchmarkçš„æ€§èƒ½è¡¨çŽ°ï¼Œå¯¹é•¿åº¦ä¸º100å­—èŠ‚çš„ä¸¤ä¸ªå­—èŠ‚åˆ‡ç‰‡è¿›è¡Œå¼‚æˆ–
// è¿ç®—ï¼Œè¯¥æ–¹æ³•æ¯” safeXORBytes æ–¹æ³•çš„39.45 ns/opï¼Œå¿«äº†å¤§çº¦1.5å€ã€‚
// è¯¥æ–¹æ³•çš„è¿ç®—é€Ÿåº¦æ¯”è¾ƒå¿«çš„åŽŸå› åœ¨äºŽä¸‹é¢çš„ä»£ç ï¼š
//
//	aw := *(*[]uintptr)(unsafe.Pointer(&a))
//	bw := *(*[]uintptr)(unsafe.Pointer(&b))
//
// ç¬¬ä¸€é‚£è¡Œä»£ç çš„ä½œç”¨æ˜¯ä»Žåˆ‡ç‰‡açš„å·¦ä¾§å¼€å§‹ï¼Œæ¯8ä¸ªå­—èŠ‚ä¼šè¢«ä»¥å°ç«¯å­˜å‚¨æ¨¡å¼è¿žæˆä¸€ä¸ª64ä½çš„åœ°å€å€¼ï¼Œç„¶åŽå­˜å…¥åˆ°æ–°çš„åˆ‡ç‰‡awé‡Œï¼Œ
// å°½ç®¡è¿™æ ·ï¼Œawçš„é•¿åº¦å¹¶ä¸æ˜¯ç­‰äºŽlen(a)/8ï¼Œè€Œæ˜¯ç­‰äºŽlen(a)ï¼Œä½†æ˜¯åªæœ‰aw[:len(a)/8]è¿™ä¸€æ®µæ‰æœ‰æ„ä¹‰ï¼Œbwä¸ŽawåŒç†ã€‚è¦
// é—®ä¸ºä»€ä¹ˆè¿™é‡Œæ˜¯æ¯8ä¸ªå­—èŠ‚ä¼šè¢«ä»¥å°ç«¯å­˜å‚¨æ¨¡å¼è¿žæˆä¸€ä¸ª64ä½çš„åœ°å€å€¼ï¼Œæ˜¯å› ä¸ºåœ¨64ä½çš„Ubuntu 20.04æ“ä½œç³»ç»Ÿä¸­ï¼Œåœ°å€å€¼çš„
// é•¿åº¦å°±æ˜¯64ä½ï¼Œå³æ­£å¥½8ä¸ªå­—èŠ‚ã€‚
// ä¾‹å¦‚ï¼Œå¦‚æžœåˆ‡ç‰‡a=[1 1 1 1 0 0 0 1]ï¼Œåˆ™aw[0]çš„å€¼å¦‚ä¸‹æ‰€ç¤ºï¼š
//
//	aw[0] = 0000000100000000000000000000000000000001000000010000000100000001ï¼Œç”¨æ•´æ•°è¡¨ç¤ºä¸ºï¼š72057594054770945
//
// æŽ¥ç€ï¼Œæˆ‘ä»¬å†åˆ©ç”¨å¦‚ä¸‹ä»£ç è¿›è¡Œå¼‚æˆ–è¿ç®—ï¼š
//
//	for i := 0; i < n / wordSize; i++ {
//		dw[i] = aw[i] ^ bw[i]
//	}
//
// é€Ÿåº¦ä¼šæ˜Žæ˜¾åŠ å¿«ï¼Œå› ä¸ºä¸Šé¢ä»£ç é‡Œçš„ä¸€æ¬¡å¾ªçŽ¯æ˜¯å¯¹8å¯¹å­—èŠ‚åšå¼‚æˆ–è¿ç®—ã€‚ç”±äºŽç»™å®šçš„aã€bå­—èŠ‚åˆ‡ç‰‡çš„é•¿åº¦ä¸ä¸€å®šæ˜¯8çš„æ•´æ•°å€ï¼Œå› æ­¤æˆ‘ä»¬è¿˜éœ€è¦
// åˆ©ç”¨å¦‚ä¸‹ä»£ç ï¼Œå¯¹å‰©ä¸‹çš„å­—èŠ‚åšå¼‚æˆ–è¿ç®—ï¼š
//
//	for i := n - n%wordSize; i < n; i++ {
//		dst[i] = a[i] ^ b[i]
//	}
//
// è¯¥æ–¹æ³•çš„è¿”å›žå€¼è¡¨ç¤ºå¯¹aæˆ–bä¸­å¤šå°‘ä¸ªå­—èŠ‚è¿›è¡Œäº†å¼‚æˆ–è¿ç®—ã€‚
func fastXORBytes(dst, a, b []byte) int {
	n := len(a)
	if len(b) < n {
		n = len(b)
	}
	w := n / wordSize
	if w > 0 {
		dw := *(*[]uintptr)(unsafe.Pointer(&dst))
		aw := *(*[]uintptr)(unsafe.Pointer(&a))
		bw := *(*[]uintptr)(unsafe.Pointer(&b))
		for i := 0; i < w; i++ {
			dw[i] = aw[i] ^ bw[i]
		}
	}
	for i := n - n%wordSize; i < n; i++ {
		dst[i] = a[i] ^ b[i]
	}
	return n
}

/*â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“*/

// ðŸŒ¹ä¸Žè¿ç®—ðŸŒ¹

// ANDBytes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ðŸ |æ—¥æœŸï¼š2022/10/27|
//
// ANDBytes æ–¹æ³•æŽ¥å—3ä¸ªå…¥å‚ï¼Œåˆ†åˆ«æ˜¯dstã€aã€bä¸‰ä¸ªå­—èŠ‚åˆ‡ç‰‡ï¼Œè¯¥æ–¹æ³•å®žçŽ°å¯¹ç»™å®šçš„aã€bä¸¤ä¸ªå­—èŠ‚åˆ‡ç‰‡è¿›è¡Œä¸Žè¿ç®—ï¼Œå¹¶å°†ç»“æžœ
// å­˜å‚¨åˆ°dstä¸­ï¼Œå¦‚æžœè¿è¡Œè¯¥æ–¹æ³•çš„è®¡ç®—æœºæž¶æž„å±žäºŽ{386ã€amd64ã€ppc64ã€ppc64leã€s390x}è¿™å…¶ä¸­çš„æŸä¸€ä¸ªï¼Œåˆ™æ‰§è¡Œå¿«é€Ÿç®—
// æ³• fastANDBytes æ¥è¿›è¡Œä¸Žè¿ç®—ï¼Œå¦åˆ™é‡‡ç”¨å¸¸è§„çš„ç®—æ³• safeANDBytesã€‚è¯¥æ–¹æ³•çš„è¿”å›žå€¼è¡¨ç¤ºå¯¹aæˆ–bä¸­å¤šå°‘ä¸ªå­—èŠ‚è¿›è¡Œäº†ä¸Ž
// è¿ç®—ã€‚
//
//	ä¾‹å¦‚ï¼šè¾“å…¥a=[12 34 28] b=[3 67 98 55]ï¼Œç»è¿‡è¿ç®—ï¼Œdst=[0 2 0]
//	12 xor 3 -> 1100 & 0011 -> 0000 -> 0
//	34 xor 67 -> 0100010 & 1000011 -> 0000010 -> 2
//	28 xor 98 -> 0011100 & 1100010 -> 0000000 -> 0
func ANDBytes(dst, a, b []byte) int {
	if supportUnaligned {
		return fastANDBytes(dst, a, b)
	}
	return safeANDBytes(dst, a, b)
}

// safeANDBytes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ðŸ |æ—¥æœŸï¼š2022/10/27|
//
// safeANDBytes æ–¹æ³•æŽ¥å—3ä¸ªå…¥å‚ï¼Œåˆ†åˆ«æ˜¯dstã€aã€bï¼Œè¯¥æ–¹æ³•å°±æ˜¯å¯¹ç»™å®šçš„aã€bä¸¤ä¸ªå­—èŠ‚åˆ‡ç‰‡ï¼Œè¿›è¡Œé€å­—èŠ‚çš„ä¸Žè¿ç®—ã€‚ä¸è¦æ±‚
// aã€bä¸¤ä¸ªå­—èŠ‚åˆ‡ç‰‡çš„é•¿åº¦å¿…é¡»ä¸€æ ·ï¼Œä½†æ˜¯è¦æ±‚dstå‚æ•°çš„é•¿åº¦è‡³å°‘ç­‰äºŽaã€bä¸­é•¿åº¦æœ€çŸ­çš„é‚£ä¸€ä¸ªï¼Œè¯¥æ–¹æ³•çš„è¿”å›žå€¼è¡¨ç¤ºå¯¹aæˆ–bä¸­å¤š
// å°‘ä¸ªå­—èŠ‚è¿›è¡Œäº†ä¸Žè¿ç®—ã€‚
//
//	ä¾‹å¦‚ï¼šè¾“å…¥a=[12 34 28] b=[3 67 98 55]ï¼Œç»è¿‡è¿ç®—ï¼Œdst=[0 2 0]
//	12 xor 3 -> 1100 & 0011 -> 0000 -> 0
//	34 xor 67 -> 0100010 & 1000011 -> 0000010 -> 2
//	28 xor 98 -> 0011100 & 1100010 -> 0000000 -> 0
func safeANDBytes(dst, a, b []byte) int {
	n := len(a)
	if len(b) < n {
		n = len(b)
	}
	for i := 0; i < n; i++ {
		dst[i] = a[i] & b[i]
	}
	return n
}

// fastANDBytes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ðŸ |æ—¥æœŸï¼š2022/10/27|
//
// fastANDBytes æ–¹æ³•æŽ¥å—3ä¸ªå…¥å‚ï¼Œåˆ†åˆ«æ˜¯dstã€aã€bï¼Œè¯¥æ–¹æ³•å°±æ˜¯å¯¹ç»™å®šçš„aã€bä¸¤ä¸ªå­—èŠ‚åˆ‡ç‰‡è¿›è¡Œä¸Žè¿ç®—ï¼Œå¹¶å°†ç»“æžœå­˜åˆ°
// dstä¸­ï¼Œä½†æ˜¯è¯¥æ–¹æ³•æ¯” safeANDBytes æ–¹æ³•æ›´å¿«ï¼Œæ ¹æ®benchmarkçš„æ€§èƒ½è¡¨çŽ°ï¼Œå¯¹é•¿åº¦ä¸º100å­—èŠ‚çš„ä¸¤ä¸ªå­—èŠ‚åˆ‡ç‰‡è¿›è¡Œä¸Ž
// è¿ç®—ï¼Œè¯¥æ–¹æ³•æ¯” safeANDBytes æ–¹æ³•çš„38.49 ns/opï¼Œå¿«äº†å¤§çº¦1.5å€ã€‚
// è¯¥æ–¹æ³•çš„è¿ç®—é€Ÿåº¦æ¯”è¾ƒå¿«çš„åŽŸå› åœ¨äºŽä¸‹é¢çš„ä»£ç ï¼š
//
//	aw := *(*[]uintptr)(unsafe.Pointer(&a))
//	bw := *(*[]uintptr)(unsafe.Pointer(&b))
//
// ç¬¬ä¸€è¡Œä»£ç çš„ä½œç”¨æ˜¯ä»Žåˆ‡ç‰‡açš„å·¦ä¾§å¼€å§‹ï¼Œæ¯8ä¸ªå­—èŠ‚ä¼šè¢«ä»¥å°ç«¯å­˜å‚¨æ¨¡å¼è¿žæˆä¸€ä¸ª64ä½çš„åœ°å€å€¼ï¼Œç„¶åŽå­˜å…¥åˆ°æ–°çš„åˆ‡ç‰‡awé‡Œï¼Œ
// å°½ç®¡è¿™æ ·ï¼Œawçš„é•¿åº¦å¹¶ä¸æ˜¯ç­‰äºŽlen(a)/8ï¼Œè€Œæ˜¯ç­‰äºŽlen(a)ï¼Œä½†æ˜¯åªæœ‰aw[:len(a)/8]è¿™ä¸€æ®µæ‰æœ‰æ„ä¹‰ï¼Œbwä¸ŽawåŒç†ã€‚
// è¦é—®ä¸ºä»€ä¹ˆè¿™é‡Œæ˜¯æ¯8ä¸ªå­—èŠ‚ä¼šè¢«ä»¥å°ç«¯å­˜å‚¨æ¨¡å¼è¿žæˆä¸€ä¸ª64ä½çš„åœ°å€å€¼ï¼Œæ˜¯å› ä¸ºåœ¨64ä½çš„Ubuntu 20.04æ“ä½œç³»ç»Ÿä¸­ï¼Œåœ°å€
// å€¼çš„é•¿åº¦å°±æ˜¯64ä½ï¼Œå³æ­£å¥½8ä¸ªå­—èŠ‚ã€‚
// ä¾‹å¦‚ï¼Œå¦‚æžœåˆ‡ç‰‡a=[1 1 1 1 0 0 0 1]ï¼Œåˆ™aw[0]çš„å€¼å¦‚ä¸‹æ‰€ç¤ºï¼š
//
//	aw[0] = 0000000100000000000000000000000000000001000000010000000100000001ï¼Œç”¨æ•´æ•°è¡¨ç¤ºä¸ºï¼š72057594054770945
//
// æŽ¥ç€ï¼Œæˆ‘ä»¬å†åˆ©ç”¨å¦‚ä¸‹ä»£ç è¿›è¡Œä¸Žè¿ç®—ï¼š
//
//	for i := 0; i < n / wordSize; i++ {
//		dw[i] = aw[i] & bw[i]
//	}
//
// é€Ÿåº¦ä¼šæ˜Žæ˜¾åŠ å¿«ï¼Œå› ä¸ºä¸Šé¢ä»£ç é‡Œçš„ä¸€æ¬¡å¾ªçŽ¯æ˜¯å¯¹8å¯¹å­—èŠ‚åšä¸Žè¿ç®—ã€‚ç”±äºŽç»™å®šçš„aã€bå­—èŠ‚åˆ‡ç‰‡çš„é•¿åº¦ä¸ä¸€å®šæ˜¯8çš„æ•´æ•°å€ï¼Œå› æ­¤æˆ‘ä»¬è¿˜éœ€è¦
// åˆ©ç”¨å¦‚ä¸‹ä»£ç ï¼Œå¯¹å‰©ä¸‹çš„å­—èŠ‚åšä¸Žè¿ç®—ï¼š
//
//	for i := n - n%wordSize; i < n; i++ {
//		dst[i] = a[i] & b[i]
//	}
//
// è¯¥æ–¹æ³•çš„è¿”å›žå€¼è¡¨ç¤ºå¯¹aæˆ–bä¸­å¤šå°‘ä¸ªå­—èŠ‚è¿›è¡Œäº†ä¸Žè¿ç®—ã€‚
func fastANDBytes(dst, a, b []byte) int {
	n := len(a)
	if len(b) < n {
		n = len(b)
	}
	w := n / wordSize
	if w > 0 {
		dw := *(*[]uintptr)(unsafe.Pointer(&dst))
		aw := *(*[]uintptr)(unsafe.Pointer(&a))
		bw := *(*[]uintptr)(unsafe.Pointer(&b))
		for i := 0; i < w; i++ {
			dw[i] = aw[i] & bw[i]
		}
	}
	for i := n - n%wordSize; i < n; i++ {
		dst[i] = a[i] & b[i]
	}
	return n
}

/*â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“*/

// ðŸŒ¹æˆ–è¿ç®—ðŸŒ¹

// ORBytes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ðŸ |æ—¥æœŸï¼š2022/10/27|
//
// ORBytes æ–¹æ³•æŽ¥å—3ä¸ªå…¥å‚ï¼Œåˆ†åˆ«æ˜¯dstã€aã€bä¸‰ä¸ªå­—èŠ‚åˆ‡ç‰‡ï¼Œè¯¥æ–¹æ³•å®žçŽ°å¯¹ç»™å®šçš„aã€bä¸¤ä¸ªå­—èŠ‚åˆ‡ç‰‡è¿›è¡Œæˆ–è¿ç®—ï¼Œå¹¶å°†ç»“æžœ
// å­˜å‚¨åˆ°dstä¸­ï¼Œå¦‚æžœè¿è¡Œè¯¥æ–¹æ³•çš„è®¡ç®—æœºæž¶æž„å±žäºŽ{386ã€amd64ã€ppc64ã€ppc64leã€s390x}è¿™å…¶ä¸­çš„æŸä¸€ä¸ªï¼Œåˆ™æ‰§è¡Œå¿«é€Ÿç®—
// æ³• fastORBytes æ¥è¿›è¡Œä¸Žè¿ç®—ï¼Œå¦åˆ™é‡‡ç”¨å¸¸è§„çš„ç®—æ³• safeORBytesã€‚è¯¥æ–¹æ³•çš„è¿”å›žå€¼è¡¨ç¤ºå¯¹aæˆ–bä¸­å¤šå°‘ä¸ªå­—èŠ‚è¿›è¡Œäº†æˆ–
// è¿ç®—ã€‚
//
//	ä¾‹å¦‚ï¼šè¾“å…¥a=[12 34 28] b=[3 67 98 55]ï¼Œç»è¿‡è¿ç®—ï¼Œdst=[15 99 126]
//	12 xor 3 -> 1100 | 0011 -> 0000 -> 15
//	34 xor 67 -> 0100010 | 1000011 -> 0000010 -> 99
//	28 xor 98 -> 0011100 | 1100010 -> 0000000 -> 126
func ORBytes(dst, a, b []byte) int {
	if supportUnaligned {
		return fastORBytes(dst, a, b)
	}
	return safeORBytes(dst, a, b)
}

// safeORBytes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ðŸ |æ—¥æœŸï¼š2022/10/27|
//
// safeORBytes æ–¹æ³•æŽ¥å—3ä¸ªå…¥å‚ï¼Œåˆ†åˆ«æ˜¯dstã€aã€bï¼Œè¯¥æ–¹æ³•å°±æ˜¯å¯¹ç»™å®šçš„aã€bä¸¤ä¸ªå­—èŠ‚åˆ‡ç‰‡ï¼Œè¿›è¡Œé€å­—èŠ‚çš„æˆ–è¿ç®—ã€‚ä¸è¦æ±‚
// aã€bä¸¤ä¸ªå­—èŠ‚åˆ‡ç‰‡çš„é•¿åº¦å¿…é¡»ä¸€æ ·ï¼Œä½†æ˜¯è¦æ±‚dstå‚æ•°çš„é•¿åº¦è‡³å°‘ç­‰äºŽaã€bä¸­é•¿åº¦æœ€çŸ­çš„é‚£ä¸€ä¸ªï¼Œè¯¥æ–¹æ³•çš„è¿”å›žå€¼è¡¨ç¤ºå¯¹aæˆ–bä¸­
// å¤šå°‘ä¸ªå­—èŠ‚è¿›è¡Œäº†æˆ–è¿ç®—ã€‚
//
//	ä¾‹å¦‚ï¼šè¾“å…¥a=[12 34 28] b=[3 67 98 55]ï¼Œç»è¿‡è¿ç®—ï¼Œdst=[15 99 126]
//	12 xor 3 -> 1100 | 0011 -> 1111 -> 15
//	34 xor 67 -> 0100010 | 1000011 -> 1100011 -> 99
//	28 xor 98 -> 0011100 | 1100010 -> 1111110 -> 126
func safeORBytes(dst, a, b []byte) int {
	n := len(a)
	if len(b) < n {
		n = len(b)
	}
	for i := 0; i < n; i++ {
		dst[i] = a[i] | b[i]
	}
	return n
}

// fastORBytes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ðŸ |æ—¥æœŸï¼š2022/10/27|
//
// fastORBytes æ–¹æ³•æŽ¥å—3ä¸ªå…¥å‚ï¼Œåˆ†åˆ«æ˜¯dstã€aã€bï¼Œè¯¥æ–¹æ³•å°±æ˜¯å¯¹ç»™å®šçš„aã€bä¸¤ä¸ªå­—èŠ‚åˆ‡ç‰‡è¿›è¡Œæˆ–è¿ç®—ï¼Œå¹¶å°†ç»“æžœå­˜åˆ°
// dstä¸­ï¼Œä½†æ˜¯è¯¥æ–¹æ³•æ¯” safeORBytes æ–¹æ³•æ›´å¿«ï¼Œæ ¹æ®benchmarkçš„æ€§èƒ½è¡¨çŽ°ï¼Œå¯¹é•¿åº¦ä¸º100å­—èŠ‚çš„ä¸¤ä¸ªå­—èŠ‚åˆ‡ç‰‡è¿›è¡Œæˆ–
// è¿ç®—ï¼Œè¯¥æ–¹æ³•æ¯” safeORBytes æ–¹æ³•çš„40.69 ns/opï¼Œå¿«äº†å¤§çº¦1.8å€ã€‚
// è¯¥æ–¹æ³•çš„è¿ç®—é€Ÿåº¦æ¯”è¾ƒå¿«çš„åŽŸå› åœ¨äºŽä¸‹é¢çš„ä»£ç ï¼š
//
//	aw := *(*[]uintptr)(unsafe.Pointer(&a))
//	bw := *(*[]uintptr)(unsafe.Pointer(&b))
//
// ç¬¬ä¸€è¡Œä»£ç çš„ä½œç”¨æ˜¯ä»Žåˆ‡ç‰‡açš„å·¦ä¾§å¼€å§‹ï¼Œæ¯8ä¸ªå­—èŠ‚ä¼šè¢«ä»¥å°ç«¯å­˜å‚¨æ¨¡å¼è¿žæˆä¸€ä¸ª64ä½çš„åœ°å€å€¼ï¼Œç„¶åŽå­˜å…¥åˆ°æ–°çš„åˆ‡ç‰‡awé‡Œï¼Œ
// å°½ç®¡è¿™æ ·ï¼Œawçš„é•¿åº¦å¹¶ä¸æ˜¯ç­‰äºŽlen(a)/8ï¼Œè€Œæ˜¯ç­‰äºŽlen(a)ï¼Œä½†æ˜¯åªæœ‰aw[:len(a)/8]è¿™ä¸€æ®µæ‰æœ‰æ„ä¹‰ï¼Œbwä¸ŽawåŒç†ã€‚
// è¦é—®ä¸ºä»€ä¹ˆè¿™é‡Œæ˜¯æ¯8ä¸ªå­—èŠ‚ä¼šè¢«ä»¥å°ç«¯å­˜å‚¨æ¨¡å¼è¿žæˆä¸€ä¸ª64ä½çš„åœ°å€å€¼ï¼Œæ˜¯å› ä¸ºåœ¨64ä½çš„Ubuntu 20.04æ“ä½œç³»ç»Ÿä¸­ï¼Œåœ°å€
// å€¼çš„é•¿åº¦å°±æ˜¯64ä½ï¼Œå³æ­£å¥½8ä¸ªå­—èŠ‚ã€‚
// ä¾‹å¦‚ï¼Œå¦‚æžœåˆ‡ç‰‡a=[1 1 1 1 0 0 0 1]ï¼Œåˆ™aw[0]çš„å€¼å¦‚ä¸‹æ‰€ç¤ºï¼š
//
//	aw[0] = 0000000100000000000000000000000000000001000000010000000100000001ï¼Œç”¨æ•´æ•°è¡¨ç¤ºä¸ºï¼š72057594054770945
//
// æŽ¥ç€ï¼Œæˆ‘ä»¬å†åˆ©ç”¨å¦‚ä¸‹ä»£ç è¿›è¡Œæˆ–è¿ç®—ï¼š
//
//	for i := 0; i < n / wordSize; i++ {
//		dw[i] = aw[i] | bw[i]
//	}
//
// é€Ÿåº¦ä¼šæ˜Žæ˜¾åŠ å¿«ï¼Œå› ä¸ºä¸Šé¢ä»£ç é‡Œçš„ä¸€æ¬¡å¾ªçŽ¯æ˜¯å¯¹8å¯¹å­—èŠ‚åšæˆ–è¿ç®—ã€‚ç”±äºŽç»™å®šçš„aã€bå­—èŠ‚åˆ‡ç‰‡çš„é•¿åº¦ä¸ä¸€å®šæ˜¯8çš„æ•´æ•°å€ï¼Œå› æ­¤æˆ‘ä»¬è¿˜éœ€è¦
// åˆ©ç”¨å¦‚ä¸‹ä»£ç ï¼Œå¯¹å‰©ä¸‹çš„å­—èŠ‚åšæˆ–è¿ç®—ï¼š
//
//	for i := n - n%wordSize; i < n; i++ {
//		dst[i] = a[i] | b[i]
//	}
//
// è¯¥æ–¹æ³•çš„è¿”å›žå€¼è¡¨ç¤ºå¯¹aæˆ–bä¸­å¤šå°‘ä¸ªå­—èŠ‚è¿›è¡Œäº†æˆ–è¿ç®—ã€‚
func fastORBytes(dst, a, b []byte) int {
	n := len(a)
	if len(b) < n {
		n = len(b)
	}
	w := n / wordSize
	if w > 0 {
		dw := *(*[]uintptr)(unsafe.Pointer(&dst))
		aw := *(*[]uintptr)(unsafe.Pointer(&a))
		bw := *(*[]uintptr)(unsafe.Pointer(&b))
		for i := 0; i < w; i++ {
			dw[i] = aw[i] | bw[i]
		}
	}
	for i := n - n%wordSize; i < n; i++ {
		dst[i] = a[i] | b[i]
	}
	return n
}

/*â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“â›“*/

// TestBytes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ðŸ |æ—¥æœŸï¼š2022/10/27|
//
// TestBytes æ–¹æ³•æŽ¥å—ä¸€ä¸ªå­—èŠ‚åˆ‡ç‰‡pä½œä¸ºè¾“å…¥å‚æ•°ï¼Œè¯¥æ–¹æ³•å®žçŽ°å¯¹ç»™å®šçš„å­—èŠ‚åˆ‡ç‰‡pè¿›è¡Œæ£€æŸ¥ï¼Œåˆ¤æ–­pä¸­
// æ˜¯å¦å­˜åœ¨å€¼ä¸ºéž0çš„å­—èŠ‚ï¼Œå¦‚æžœå­˜åœ¨ï¼Œç›´æŽ¥è¿”å›žtrueï¼Œå¦åˆ™è¿”å›žfalseã€‚å¦‚æžœè¿è¡Œè¯¥æ–¹æ³•çš„è®¡ç®—æœºæž¶æž„å±ž
// äºŽ{386ã€amd64ã€ppc64ã€ppc64leã€s390x}è¿™å…¶ä¸­çš„æŸä¸€ä¸ªï¼Œåˆ™æ‰§è¡Œå¿«é€Ÿç®—æ³• fastTestBytes
// è¿›è¡Œè®¡ç®—ï¼Œå¦åˆ™é‡‡ç”¨å¸¸è§„çš„ç®—æ³• safeTestBytesã€‚
func TestBytes(p []byte) bool {
	if supportUnaligned {
		return fastTestBytes(p)
	}
	return safeTestBytes(p)
}

// safeTestBytes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ðŸ |æ—¥æœŸï¼š2022/10/27|
//
// safeTestBytes æŽ¥å—ä¸€ä¸ªå­—èŠ‚åˆ‡ç‰‡pä½œä¸ºå…¥å‚ï¼Œç„¶åŽé€ä¸ªå­—èŠ‚æ£€æŸ¥æ˜¯å¦å­˜åœ¨ä¸ç­‰äºŽ0çš„å­—èŠ‚ï¼Œå¦‚æžœå­˜åœ¨ï¼Œåˆ™ç›´æŽ¥è¿”å›žtrueï¼Œ
// å¦‚æžœéåŽ†å®Œä¹Ÿæ²¡å‘çŽ°ä¸ç­‰äºŽ0çš„å­—èŠ‚ï¼Œå³pä¸­çš„æ‰€æœ‰å­—èŠ‚éƒ½ç­‰äºŽ0ï¼Œåˆ™è¿”å›žfalseã€‚
func safeTestBytes(p []byte) bool {
	for i := 0; i < len(p); i++ {
		if p[i] != 0 {
			return true
		}
	}
	return false
}

// fastTestBytes â™ |ä½œè€…ï¼šå´ç¿”å®‡| ðŸ |æ—¥æœŸï¼š2022/10/27|
//
// fastTestBytes æŽ¥å—ä¸€ä¸ªå­—èŠ‚åˆ‡ç‰‡pä½œä¸ºå…¥å‚ï¼Œè¯¥æ–¹æ³•ä¹Ÿæ˜¯åˆ¤æ–­å­—èŠ‚åˆ‡ç‰‡pä¸­æ˜¯å¦å­˜åœ¨ä¸ä¸º0çš„å­—èŠ‚ï¼Œå¦‚æžœå­˜åœ¨ï¼Œåˆ™è¿”å›žtrueï¼Œå¦åˆ™è¿”
// å›žfalseï¼Œä½†æ˜¯è¯¥æ–¹æ³•æ¯” safeTestBytes æ–¹æ³•çš„æ‰§è¡Œé€Ÿåº¦è¦å¿«ï¼Œæ ¹æ®benchmarkçš„æ€§èƒ½è¡¨çŽ°ï¼Œå¯¹é•¿åº¦ä¸º100å­—èŠ‚çš„å­—èŠ‚åˆ‡ç‰‡è¿›è¡Œè®¡ç®—ï¼Œ
// è¯¥æ–¹æ³•æ¯” safeTestBytes æ–¹æ³•çš„48.69 ns/opï¼Œå¿«äº†å¤§çº¦3å€ã€‚ï¼ˆæµ‹è¯•çš„å­—èŠ‚åˆ‡ç‰‡ä¸­æ¯ä¸ªå­—èŠ‚çš„å€¼éƒ½ç­‰äºŽ0ï¼‰
// è¯¥æ–¹æ³•çš„è¿ç®—é€Ÿåº¦æ¯”è¾ƒå¿«çš„åŽŸå› åœ¨äºŽä¸‹é¢çš„ä»£ç ï¼š
//
//	pw := *(*[]uintptr)(unsafe.Pointer(&p))
//
// ä¸Šé¢ä»£ç çš„ä½œç”¨æ˜¯ä»Žåˆ‡ç‰‡pçš„å·¦ä¾§å¼€å§‹ï¼Œæ¯8ä¸ªå­—èŠ‚ä¼šè¢«ä»¥å°ç«¯å­˜å‚¨æ¨¡å¼è¿žæˆä¸€ä¸ª64ä½çš„åœ°å€å€¼ï¼Œç„¶åŽå­˜å…¥åˆ°æ–°çš„åˆ‡ç‰‡pwé‡Œï¼Œ
// å°½ç®¡è¿™æ ·ï¼Œpwçš„é•¿åº¦å¹¶ä¸æ˜¯ç­‰äºŽlen(a)/8ï¼Œè€Œæ˜¯ç­‰äºŽlen(a)ï¼Œä½†æ˜¯åªæœ‰aw[:len(a)/8]è¿™ä¸€æ®µæ‰æœ‰æ„ä¹‰ã€‚è¦é—®ä¸ºä»€ä¹ˆ
// è¿™é‡Œæ˜¯æ¯8ä¸ªå­—èŠ‚ä¼šè¢«ä»¥å°ç«¯å­˜å‚¨æ¨¡å¼è¿žæˆä¸€ä¸ª64ä½çš„åœ°å€å€¼ï¼Œæ˜¯å› ä¸ºåœ¨64ä½çš„Ubuntu 20.04æ“ä½œç³»ç»Ÿä¸­ï¼Œåœ°å€å€¼çš„é•¿åº¦
// å°±æ˜¯64ä½ï¼Œå³æ­£å¥½8ä¸ªå­—èŠ‚ã€‚
// ä¾‹å¦‚ï¼Œå¦‚æžœåˆ‡ç‰‡p=[1 1 1 1 0 0 0 1]ï¼Œåˆ™pw[0]çš„å€¼å¦‚ä¸‹æ‰€ç¤ºï¼š
//
//	pw[0] = 0000000100000000000000000000000000000001000000010000000100000001ï¼Œç”¨æ•´æ•°è¡¨ç¤ºä¸ºï¼š72057594054770945
//
// æŽ¥ç€ï¼Œæˆ‘ä»¬å†åˆ©ç”¨å¦‚ä¸‹ä»£ç åˆ¤æ–­å­—èŠ‚æ˜¯å¦ç­‰äºŽ0ï¼š
//
//	for i := 0; i < n / wordSize; i++ {
//		if pw[i] != 0 {
//			return true
//		}
//	}
//
// é€Ÿåº¦ä¼šæ˜Žæ˜¾åŠ å¿«ï¼Œå› ä¸ºä¸Šé¢ä»£ç é‡Œçš„ä¸€æ¬¡å¾ªçŽ¯æ˜¯å¯¹8å­—èŠ‚è¿›è¡Œåˆ¤æ–­ã€‚ç”±äºŽç»™å®šçš„å­—èŠ‚åˆ‡ç‰‡pçš„é•¿åº¦ä¸ä¸€å®šæ˜¯8çš„æ•´æ•°å€ï¼Œå› æ­¤æˆ‘ä»¬è¿˜éœ€è¦
// åˆ©ç”¨å¦‚ä¸‹ä»£ç ï¼Œå¯¹å‰©ä¸‹çš„å­—èŠ‚è¿›è¡Œåˆ¤æ–­ï¼š
//
//	for i := n - n%wordSize; i < n; i++ {
//		if p[i] != 0 {
//			return true
//		}
//	}
func fastTestBytes(p []byte) bool {
	n := len(p)
	w := n / wordSize
	if w > 0 {
		pw := *(*[]uintptr)(unsafe.Pointer(&p))
		for i := 0; i < w; i++ {
			if pw[i] != 0 {
				return true
			}
		}
	}
	for i := n - n%wordSize; i < n; i++ {
		if p[i] != 0 {
			return true
		}
	}
	return false
}